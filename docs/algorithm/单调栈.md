# 单调栈

## 每日温度

> 请根据每日 气温 列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

> 输入:temperatures = [73, 74, 75, 71, 69, 72, 76, 73],输出：[1, 1, 4, 2, 1, 1, 0, 0]

构建一个单调递增栈

```js
var dailyTemperatures = function(temperatures) {
    const n = temperatures.length;
    const res = Array(n).fill(0);
    const stack = [];  // 递增栈：用于存储元素右面第一个比他大的元素下标
    stack.push(0);
    for (let i = 1; i < n; i++) {
        while (stack.length && temperatures[i] > temperatures[stack[stack.length - 1]]) {
            const top = stack.pop();
            res[top] = i - top;
        }
        stack.push(i);
    }
    return res;
};
```
## 下一个更大元素 I
> 给定两个 没有重复元素 的数组 nums1 和 nums2 ，其中nums1 是 nums2 的子集。找到 nums1 中每个元素在 nums2 中的下一个比其大的值。,如果不存在,则将其置为 -1。

示例 1:

输入: nums1 = [4,1,2], nums2 = [1,3,4,2].  
输出: [-1,3,-1]  
解释:  
  对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。
  对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。
  对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。

示例 2:  
输入: nums1 = [2,4], nums2 = [1,2,3,4].  
输出: [3,-1]  
解释:  
  对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。
  对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出-1 。

1. 暴力解法
```js
function L(nums1, nums2) {

  let stack = Array(nums1.length).fill(-1); 
  for (let i = 0; i < nums1.length; i++) {
    let j = nums1.findIndex(item => item > nums2[i]);
    if (j === -1) {
      continue
    }
    for (; j < nums2.length; j++) {
      if (nums2[j] > nums1[i]) {
        stack[i] = nums2[j];
        break;
      }
    }
  }
  return stack;
}
let r = L([2,4], [1,2,3,4]);
```

1. 单调栈
:::info
注意题目中说是两个没有重复元素 的数组 nums1 和 nums2。  
没有重复元素，我们就可以用map来做映射了。根据数值快速找到下标，还可以判断nums2[i]是否在nums1中出现过。  

单调递增栈
:::
   ```js
  var nextGreaterElement = function (nums1, nums2) {
    let stack = [];
    let map = new Map();

    for (let i = 0; i < nums2.length; i++) {
      while (stack.length && nums2[i] > nums2[stack[stack.length - 1]]) {
        let index = stack.pop();
        map.set(nums2[index], nums2[i]);
      }
      stack.push(i);
    }

     // 构建单调递增栈 
    // Map { 1 => 2, 2 => 3, 3 => 4 }
    // map 

    let res = [];
    for (let j = 0; j < nums1.length; j++) {
      res[j] = map.get(nums1[j]) || -1;
    }

    return res;
 };

let r1 = nextGreaterElement([2,4], [1,2,3,4])
```
## [接雨水](https://www.programmercarl.com/0042.%E6%8E%A5%E9%9B%A8%E6%B0%B4.html#%E6%80%9D%E8%B7%AF)

> 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

<img src="@img/20210713205038.png" />
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]  
输出：6  
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。

### 暴力解法
```js
//暴力解法
var trap = function(height) {
    const len = height.length;
    let sum = 0;
    for(let i = 0; i < len; i++){
        // 第一个柱子和最后一个柱子不接雨水
        if(i == 0 || i == len - 1) continue;
        let rHeight = height[i]; // 记录右边柱子的最高高度
        let lHeight = height[i]; // 记录左边柱子的最高高度
        for(let r = i + 1; r < len; r++){
            if(height[r] > rHeight) rHeight = height[r];
        }
        for(let l = i - 1; l >= 0; l--){
            if(height[l] > lHeight) lHeight = height[l];
        }
        let h = Math.min(lHeight, rHeight) - height[i];
        if(h > 0) sum += h;
    }
    return sum;
};
```

### 单调栈 js数组作为栈
```js
  var trap = function(height) {
    const len = height.length;
    if(len <= 2) return 0; // 可以不加
    const st = [];// 存着下标，计算的时候用下标对应的柱子高度
    st.push(0);
    let sum = 0;

    for(let i = 1; i < len; i++){
        if(height[i] < height[st[st.length - 1]]){ // 情况一
            st.push(i);
        }
        if (height[i] == height[st[st.length - 1]]) {  // 情况二
            st.pop(); // 其实这一句可以不加，效果是一样的，但处理相同的情况的思路却变了。
            st.push(i);
        } else { // 情况三
            while (st.length !== 0 && height[i] > height[st[st.length - 1]]) { // 注意这里是while
                let mid = st[st.length - 1];
                st.pop();
                if (st.length !== 0) {
                    let h = Math.min(height[st[st.length - 1]], height[i]) - height[mid];
                    let w = i - st[st.length - 1] - 1; // 注意减一，只求中间宽度
                    sum += h * w;
                }
            }
            st.push(i);
        }
    }
    return sum;
};
```