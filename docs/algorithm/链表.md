# 链表
## 定义
```ts
class ListNode {
  public val: number;
  public next: ListNode|null = null;
  constructor(value?: number,next?:ListNode|null) {
    this.val = value;
    this.next = next;
  }
}
```
<img src="@img/listNode.png"/>

## 移除链表元素
题意：删除链表中等于给定值 val 的所有节点。
>示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]

>示例 2： 输入：head = [], val = 1 输出：[]

> 示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

<img src="@img/removeListNode.png"/>
使用虚拟头结点,因为头部也可能是要删除的节点 

:::tip 
`let cur = ret`,是把 `cur` 当做了 `ret` 指针,其实还是一直在修改 `ret`, 只是 `ret` 没有移动  

只有当 `cur.next.val != val` 才可以继续移动 cur
:::

```js
  /**
  * @param {ListNode} head
  * @param {number} val
  * @return {ListNode}
  */
  var removeElements = function(head, val) {
      const ret = new ListNode(0, head);
      // 指针
      let cur = ret;
      while(cur.next) {
          if(cur.next.val === val) {
              cur.next = cur.next.next;
              continue;
          }
          cur = cur.next;
      }
      return ret.next;
  };
```
## 反转链表
>题意：反转一个单链表。
>示例: 输入: 1->2->3->4->5->NULL 输出: 5->4->3->2->1->NULL

<img src="@img/reverListNode.png"/>

首先定义一个cur指针，指向头结点，再定义一个pre指针，初始化为null。  
首先要把 cur->next 节点用tmp指针保存一下，也就是保存一下这个节点  
因为接下来要改变 cur->next 的指向了，将cur->next 指向pre ，此时已经反转了第一个节点了。  
接下来，就是循环走如下代码逻辑了，继续移动pre和cur指针。  

最后，cur 指针已经指向了null，循环结束，链表也反转完毕了。 此时我们return pre指针就可以了，pre指针就指向了新的头结点。
<img src="@img/206.翻转链表.gif"/>

```js
// 双指针：
var reverseList = function(head) {
    if(!head || !head.next) return head;
    let temp = null, pre = null, cur = head;

    while(cur) {
        // 保留下一个节点
        temp = cur.next;
        // 反转指向 空
        cur.next = pre;
        // 移动指针
        pre = cur;
        cur = temp;
    }
    return pre;
};
```

## 删除链表的倒数第N个节点
>题意：给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

<img src="@img/删除链表倒数第N个节点.png"/>

假设链表的长度是length，要删除倒数第n个节点，也就是删除正数第length-n+1个节点。

### 思路
双指针的经典应用，如果要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。删掉slow所指向的节点就可以了

<img src="@img/删除倒数第N个节点.png"/>

```js
function removeNthFromEnd(head: ListNode | null, n: number): ListNode | null {
 let t = new ListNode(0,head);
 let slow = t
 let fast =  t

 while(n--){
  fast = fast.next;
 }

 while(fast.next!=null){
  fast = fast.next;
  slow = slow.next
 }

 slow.next = slow.next.next;
 return t.next
};
```

## 链表相交
> 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 

例1:
<img src="@img/交叉链表.png"/>

> 输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3  
> 输出：Intersected at '8'  
> 解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。  
> 从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。
> 在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。


例2:
<img src="@img/交叉链表2.png"/>

> 输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
>输出：null  
>解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。  
>由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。  
>这两个链表不相交，因此返回 null 。

### 思路
使用 hash 记录

```js
var getIntersectionNode = function(headA, headB) {
    const visited = new Set();
    let temp = headA;
    while (temp !== null) {
        visited.add(temp);
        temp = temp.next;
    }
    temp = headB;
    while (temp !== null) {
        if (visited.has(temp)) {
            return temp;
        }
        temp = temp.next;
    }
    return null;
};
```

使用 [双指针](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/solutions/1395092/lian-biao-xiang-jiao-by-leetcode-solutio-2kne/)

```js
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) {
        return null;
    }
    let pA = headA, pB = headB;
    while (pA !== pB) {
        pA = pA === null ? headB : pA.next;
        pB = pB === null ? headA : pB.next;
    }
    return pA;
};
```
