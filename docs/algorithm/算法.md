# 算法
**常用的算法**

## [排序](https://juejin.cn/post/7219249005905149989)

### 快速排序

```js
  function quickSort(arr){
  if (arr.length <= 1) return arr;
  let left = [],right = [],cur = arr[0];
  
  for(let i =1;i<arr.length;i++){
    if(arr[i]>cur){
      right.push(arr[i])
    }else {
      left.push(arr[i])
    }
  }
  return quickSort(left).concat(cur,quickSort(right))
}
```
### 插入排序
```js
  function insertedSort(arr) {
	for (let j = 1; j < arr.length; j++) {
		let i = j - 1, curr = arr[j];
		// curr 是 未排序的第一项，i 是拍完序 的最后一项下标
		while (i > 0 && curr < arr[i]) {
			arr[i + 1] = arr[i]
			i--
		}
		arr[i + 1] = curr
	}
}
insertedSort([1, 2, 4, 3]) // [1,2,3,4]
```
### 选择排序
```js
    function selectedSort(arr) {
      //2. 执行 n - 1 次
      for (let i = 0; i < arr.length; i++) {
     // 1. 选择 最小值，然后把 这个最小值 与头部进行交换，找到的最小值就不再遍歷了
        let minIndex = i;
        for (let j = i; j < arr.length; j++) {
          if (arr[j] < arr[minIndex]) {
            minIndex = j;
          }
        }
        [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];
      }
      return arr;
}
```
## 数组
### [二分查找](https://programmercarl.com/0704.%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html)
#### 左闭右闭区间
```js
  var search = function(nums, target) {
    // right是数组最后一个数的下标，num[right]在查找范围内，是左闭右闭区间
    let mid, left = 0, right = nums.length - 1;
    // 当left=right时，由于nums[right]在查找范围内，所以要包括此情况
    while (left <= right) {
        // 位运算 + 防止大数溢出
        mid = left + ((right - left) >> 1);
        // 如果中间数大于目标值，要把中间数排除查找范围，所以右边界更新为mid-1；如果右边界更新为mid，那中间数还在下次查找范围内
        if (nums[mid] > target) {
            right = mid - 1;  // 去左面闭区间寻找
        } else if (nums[mid] < target) {
            left = mid + 1;   // 去右面闭区间寻找
        } else {
            return mid;
        }
    }
    return -1;
};
```
#### 左闭右开区间
```js
var search = function(nums, target) {
  // right是数组最后一个数的下标+1，nums[right]不在查找范围内，是左闭右开区间
  let mid, left = 0, right = nums.length;    
  // 当left=right时，由于nums[right]不在查找范围，所以不必包括此情况
  while (left < right) {
    // 位运算 + 防止大数溢出
    mid = left + ((right - left) >> 1);
    // 如果中间值大于目标值，中间值不应在下次查找的范围内，但中间值的前一个值应在；
    // 由于right本来就不在查找范围内，所以将右边界更新为中间值
    // 如果更新右边界为mid-1则将中间值的前一个值也踢出了下次寻找范围
    if (nums[mid] > target) {
      right = mid; 
    } else if (nums[mid] < target) {
      left = mid + 1;  
    } else {
      return mid;
    }
  }
  return -1;
};
```
## 双指针
**双指针法（快慢指针法）： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作**
定义快慢指针  
- 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
- 慢指针：指向更新 新数组下标的位置

### 移除元素
给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组
```js
function removeElement(nums: number[], val: number): number {
  let slowIndex = 0
  for(let fastIndex = 0;fastIndex< nums.length;fastIndex ++ ){
    if(nums[fastIndex] !== val){
      nums[slowIndex ++ ] = nums[fastIndex]
    }
  }
  return slowIndex
};
```
<img src="../assets//img/27.移除元素-双指针法.gif"/>