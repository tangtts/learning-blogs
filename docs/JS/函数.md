# 函数
关于函数的一切,函数定义,属性,常用的函数编程...
## 作用域
:::tip
 只有在函数中有作用域的概念，在`if/for` 中没有作用域的概念
:::
### 块级作用域
 在 `js` 中，`{}` 不仅代表了对象字面量，也代表了 ***代码块*** 

`let` 创建块级作用域的意思是以 `{}`包裹可以形成一个代码块，比如 `if/for`, let在该代码块中有效

 ### 静态作用域
 在函数定义的时候，带了一个[[scope]]的属性,包含着创建时的词法环境; 在函数创建已经确定好了函数的静态作用域了  
 比如 `你是一个河南人,在出生的时候已经确定了,有些东西不论带到哪里都去不掉`

### 动态作用域
:::tip
特指 `this`,可以根据调用方的不同，切换不同的执行环境  
箭头函数在创建时候就已经确定`this`指向,《开墙透绿》

回调函数中的 `this` 指向 window
:::
```js
var name = 1;

var obj1 = {
	name:2,
	fn1:function(){
		console.log(this.name);
	},

	fn2:()=>console.log(this.name),

	fn3:function(){
		return function(){
			console.log(this.name)
		}
	},

	fn4:function(){
		// 和 fn4 的 this 保持一致 
		return ()=>{
			console.log(this.name)
		}
	},
}

let obj2 ={
	name:3
}

// 函数 在 堆内存里存储 
// fn1 -> 指向一个地址， 这个地址 指向 这个函数地址
// 所以可以在其他调用环境中执行
// 其实this 指向的 执行环境

obj1.fn1() // 2
obj1.fn1.call(obj2) // 3
obj1.fn2() // 1
obj1.fn2.call(obj2) // 1
obj1.fn3()() // 1
obj1.fn3.call(obj2)() // 1

obj1.fn4()() // 2
obj1.fn4.call(obj2)() // 3
```

## 闭包
:::tip
函数的定义和执行不在同一个作用域内，叫做闭包 
以前的定义是 外层函数引用内部变量,导致内部变量无法释放
:::
```js
function after(times,callback){
 return function(){
   if(--times){
    callback()
  }
 } 
}

let cb = atfter(2,function(){
  console.log(11)
})
```
## 尾递归
尾递归的要求是递归 return 是一个函数, `return fn() + 1` 不能算是一个尾递归
```js
function factorial(n, total = 1) { 
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
factorial(5) // 120
```

```js
// 这道题有个规律，第一项加上第二项永远等于第三项：
// 1 + 1 = 2；1 + 2 = 3；2 + 3  // = 5；3 + 5 = 8 ....

// 倒序相加
function factorial(n) {
  // 第一项和第二项都返回1
  if (n === 1 || n === 2) return 1;
  // 我们只要返回 n - 1（n的前一项）与 n - 2（n的前两项）的和便是我们要的值
  return factorial(n - 1) + factorial(n - 2);
}


function factorial(n, sum1 = 1, sum2 = 1) { // 求最终的值，不是求和
  if (n === 1 || n === 2) return sum2;
  return factorial(n - 1, sum2, sum1 + sum2);
}
```