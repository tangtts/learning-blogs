
# 其他
一些无法分类的小杂项


## 栈
> 栈是先进后出（FILO）的线性结构。

:::tip 📝
只有一个口！因为只有一个口，所以导致最先进去的最后才出来，所以就叫先进后出，或者叫作 FILO（First In Last Out）。
:::

栈最常用的地方就是计算机的函数调用，不管何种语言，最先被调用的一定最后返回

```js
function A() {
  B();
}

function B() {
  function C();
}
```
我们经常说 `函数栈`，也就是这个道理,凡是具有对称性要求的场景，都优先考虑使用栈。

## 队列
> 队列是先进先出（FIFO）的线性结构。

:::tip
两个口！因为两个口，一个进一个出，那么先进去的肯定先跑到出口，所以就叫先进先出，或者叫作 FIFO（First In First Out）
:::

队列就像排队一样，谁先排队，谁先出队

## 二进制
<blue>进制代表的是不往前进可以表示最大的数字</blue>

 对于 10 进制来说, 数字 `10` 中的 `1` 代表的是已经够 10个数字了(0-9),需要前进1, 后面跟着 的 0 代表还没开始计数，就像算盘中的 `满 5 进 1`  

对于 `2` 进制来说, 只有 `0 / 1` 两个状态,再往前需要前进一位  

二进制的最大优点：位运算。  
| p|	q |	p 与 q |	p 或 q|
| :--: | :--: | :--: | :--: |
|0 |	0 |	0 |	0 |
|1 |	0 |	0 |	1 |
|0 |	1 |	0 |	1 |
|1 |	1 |	1 |	1 |

p 与 q 等于取交集，全部为 1 才为 1；p 或 q 等于取并集，全部为 0 才为 0

```js
100 ∩ 011=000, 100 ∪ 011=111
```

给定一个数 n，怎么判断 n 是不是 2 的 n 次方呢？  

如果一个数是 2 的 n 次方 ,那么这个数字必须 第一位 是 `1`,因为有进位

```java
public boolean isPowerOfTwo(int n) {
    return (n>0) && ((n & (n - 1)) == 0);
}
```
我们知道，10 的 n 次方最高位是 1，其他位都是 0；2 的 n 次方也是同理。也就是说：如果一个数 a 是 2 的 n 次方，那么 a 的最高位就是 1，其他位全是 0；那么，a-1 呢，就变成高位是 0，其他位全是 1 了。  

我们将 8 位二进制称作一个字节，也就是 1byte，也就是: 1byte = 8bit，也就是 8 个二进制位；因为最高位要用来表示符号位，所以，1 个 byte 的大小范围就是 [−2^7, 2^7 − 1]。

负数范围为 −2^7 到 -1, 一共有 `2^7`, 正数范围为  1 - 2^7,共有 2^7 - 1，一共有 `2^7 - 1` 个。0 呢？0 的符号位是 0，也算是正数，所以正数应该是：0 ~ 2^7，也是 2^7 个，跟负数总数是一样的。

因为有一个符号位 `-0` 和 `+0` 只算一个，所以要减去 1