# 工具包
## vite
### vite 原理
1. 扫描整个项目,找到依赖的第三方模块
2. 编译第三方模块,放到 .vite 目录中
3. 重写返回的导入路径,指向 .vite 目录中的编译后的文件  
   `import {} from 'xxx'
   ->
   import {} from '/node_modules/.vite/deps/xxx'`
4. 请求服务器的时候,直接返回 `/node_modules/.vite/deps/xxx`   

## tailwindcss
### 指令@layer
1. 指令 `@layer base` 表示基础层
2. 指令 `@layer components` 表示组件层
3. 指令 `@layer utilities` 表示工具层
```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  h1 {
    @apply text-2xl;
  }
  h2 {
    @apply text-xl;
  }
}

@layer components {
  .btn-blue {
    @apply bg-blue-500 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded;
  }
}

@layer utilities {
  .filter-none {
    filter: none;
  }
  .filter-grayscale {
    filter: grayscale(100%);
  }
}
```
> Tailwind 会自动将任何 @layer 指令中的 CSS 移动到与对应的 @tailwind 规则相同的位置，因此你不必担心按特定顺序编写 CSS 以避免特异性问题。  

> 添加到图层的任何自定义 CSS 仅当该 CSS 实际用于你的 HTML 时才会包含在最终构建中，就像默认内置到 Tailwind 中的所有类一样。  

> 使用 @layer 封装任何自定义 CSS 还可以使用具有这些规则的修饰符，如 hover: 和 focus: 或响应式修饰符，如 md: 和 lg:  

## 字体
1. serif 衬线字体族
2. sans-serif 非衬线字体族
   `sans` 的意思是无
3. font-family: system-ui 系统默认字体
<img src="@img/font.webp" />   

## 语义化版本规范
版本格式:  **主版本号.次版本号.修订号**
1. 主版本号
   - 当你做了不兼容的 API 修改
2. 次版本号
   - 向下兼容的功能性新增
3. 修订号 
   - 向下兼容的问题修复

## 前进一位
**拿着 `arr[i]` 赋值给 `arr[i-1]`, 就是前进了一位**
```js
let s = ["a", "b", "c"]; // ["b","c","a"]

let s1 = s[0];

for (let i = 1; i < s.length; i++) {
  s[i - 1] = s[i];
}
s[s.length - 1] = s1;

s; // ["b","c","a"]
```

## 二进制
<blue>进制代表的是不往前进可以表示最大的数字</blue>

 对于 10 进制来说, 数字 `10` 中的 `1` 代表的是已经够 10个数字了(0-9),需要前进1, 后面跟着 的 0 代表还没开始计数，就像算盘中的 `满 5 进 1`  

对于 `2` 进制来说, 只有 `0 / 1` 两个状态,再往前需要前进一位  

二进制的最大优点：位运算。  
| p|	q |	p 与 q |	p 或 q|
| :--: | :--: | :--: | :--: |
|0 |	0 |	0 |	0 |
|1 |	0 |	0 |	1 |
|0 |	1 |	0 |	1 |
|1 |	1 |	1 |	1 |

p 与 q 等于取交集，全部为 1 才为 1；p 或 q 等于取并集，全部为 0 才为 0

```js
100 ∩ 011=000, 100 ∪ 011=111
```

给定一个数 n，怎么判断 n 是不是 2 的 n 次方呢？  

如果一个数是 2 的 n 次方 ,那么这个数字必须 第一位 是 `1`,因为有进位

```java
public boolean isPowerOfTwo(int n) {
    return (n>0) && ((n & (n - 1)) == 0);
}
```
我们知道，10 的 n 次方最高位是 1，其他位都是 0；2 的 n 次方也是同理。也就是说：如果一个数 a 是 2 的 n 次方，那么 a 的最高位就是 1，其他位全是 0；那么，a-1 呢，就变成高位是 0，其他位全是 1 了。  

我们将 8 位二进制称作一个字节，也就是 1byte，也就是: 1byte = 8bit，也就是 8 个二进制位；因为最高位要用来表示符号位，所以，1 个 byte 的大小范围就是 [−2^7, 2^7 − 1]。

负数范围为 −2^7 到 -1, 一共有 `2^7`, 正数范围为  1 - 2^7,共有 2^7 - 1，一共有 `2^7 - 1` 个。0 呢？0 的符号位是 0，也算是正数，所以正数应该是：0 ~ 2^7，也是 2^7 个，跟负数总数是一样的。

因为有一个符号位 `-0` 和 `+0` 只算一个