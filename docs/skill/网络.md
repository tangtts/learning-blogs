# 网络
在网络层面，对于前端开发者，必须要知道浏览器拥有的两大核心能力：
- 自动发出请求的能力
- 自动解析响应的能力

当发送GET请求时，浏览器不会附带请求体
1. GET 请求只能传递 ASCII 数据，遇到非 ASCII 数据需要进行编码；POST 请求没有限制
2. POST 不会被保存到浏览器的历史记录中
3. 刷新页面时，若当前的页面是通过 POST 请求得到的，则浏览器会提示用户是否重新提交。若是 GET 请求得到的页面则没有提示。

自动解析响应的能力
1. 浏览器能够自动识别响应码，当出现一些特殊的响应码时浏览器会自动完成处理，比如301( 永久 重定向 )、302(  临时重定向 )
2. 根据响应结果做不同的处理浏览器能够自动分析响应头中的Content-Type，根据不同的值进行不同处理，比如：
  - text/plain: 普通的纯文本，浏览器通常会将响应体原封不动的显示到页面上
  - text/html：html文档，浏览器通常会将响应体作为页面进行渲染
  - text/javascript或application/javascript：js代码，浏览器通常会使用JS执行引擎将它解析执行
  - text/css：css代码，浏览器会将它视为样式
  - image/jpeg：浏览器会将它视为jpg图片
  - application/octet-stream：二进制数据，会触发浏览器下载功能
  - attachment：附件，会触发下载功能该值和其他值不同，应放到Content-Disposition头中。

<img src="@img/20220428165634.png"/>

## 传输

- 应用层
  - 两个软件可以通过网络通信，那么这两个软件就是应用层
  - 应用层有很多协议
    -  `HTTP`
    -  `FTP(文件传输)`
    -  `DNS协议(域名解析)`
    -  SMTP协议(邮件传输)  
  这些协议类似于包装层的方案选择什么来装鱼，黑色袋子、麻袋、还是揣兜里，用于处理不同的场景
- 传输层
  - **传输层主要是保证消息的可靠传递**
  - 传输层协议
    - UDP协议(User Datagram Protocol,用户数据报协议)
    - TCP协议(Transmission Control Protocol,传输控制协议)
- 网络层
  - IP(Internet Protocol)协议  
    - 网络层会接收到来自传输层的“数据”，然后将这些数据拆分很多片段，主要是为了方便IP数据包的发送，理论上每个数据包最多可以存储64KB，但实际上数据包不超过1500个字节，IP路由器会转发每一个数据包，沿着一条路径从一台路由器传递到下一台路由器，直到达到目的地，然后会在**网络层重组**，因为数据是有一个封装和解封装的过程
- 数据链路层
    - 数据链路层的代表就是MAC协议(medium access control,介质访问控制)
 
     MAC地址相当于我们的身份证号，无论我们在哪个城市，它都是唯一不变的，而IP地址换个城市就会变
- 物理层  
  二进制数据可以用光纤、双绞线、同轴电缆、电力线等等，像这些传输的介质我们一般称为导向的传输介质

---
<img src="@img/20211008163417.png"/>

<img src="@img/20211008164017.png"/>

<img src="@img/202301121029498.png"/>


## TCP
### 三次握手,四次挥手
#### 三次握手
  当发送的数据过大时，会被分成一段一段的数据报，每一段数据报头部都会有TCP头部，这里面包含了很多信息，其中就有上图中的 **`SYN(Synchronize Sequence Numbers,同步序列编号，是连接建立的握手信号)`**, **`seq(sequence，数据报序号)`**,**`ACK(Acknowledge character，确认字符，只有0和1)`**, **`seq(下次应该发送的编号)`**
1. 每个链接都是从CLOSED状态开始的，当它执行一个主动打开连接操作或者被动打开连接操作，它就离开了CLOSED状态
2. 当客户端A向服务器B发送消息的时候，链接从CLOSED状态进入SYN-SENT状态  
   1.  TCP头部携带SYN=1表示 A 要跟 B 建立同步链接、seq=x表示这次发送的是序号为x的数据报、ACK=0表示还未被确认的数据报，将这三个同时发给B，
2. B成功收到消息后，CLOSED状态关闭并进入SYN-RCVD状态，表示 **🔥第一次握手成功**，
3. 此时 B 知道 A 具有发送消息的功能，但不知道的是A是否有接收信息的功能
4. 这时 B 开始发送消息，**🔥第二次握手发生了**，B的回信 携带TCP头部的信息SYN=1表示我要跟 A 建立同步链接，seq=y表示这次发送的是序号为y的数据报、ACK=1表示 A 的信被确认的数据报, *ack=x+1 表示序号为x的数据报已经收到，麻烦下次给我发x+1序号的数据报*
5. A 知道 B 可以收到自己的消息，但是 B 并不知道 A 已经收到自己的消息，所以 A 需要再次发送消息告诉 B，**🔥这时第三次握手发生了**，
6. B 知道 A 可以收到自己的消息，此时 A 和 B 双方都具有寄信和收信的能力，这一刻AB的连接就建立成功了，连接状态就变成ESTAB-LISHED，表示正常的传输状态，可以互相交流了。😘
#### 连接销毁（四次挥手）
1. 当 A 发送消息给 B："结束链接,是否还有数据"，**🚀这就是第一次挥手**，无论是客户端，还是服务端，都可以发起第一次挥手，我们暂且称为发送方，每一次请求都需要被确认才可以，所以当发送方发起第一次挥手时，发完并不会立刻就挂，而是要等接收方的回应。
2.  B 收到了 A 的消息，随后回复：“还有数据”，**🚀这就是第二次挥手**
3. 然后 B 发送数据,等 B 发送所有的数据之后,发送：“断开链接”，**🚀这是第三次挥手**
4. B 也并不知道 A 是否收到，所以 A 依然还需要进行回复：“断开链接” **🚀这是第四次挥手**


## HTTP 缓存
> 当客户端发出一个GET请求到服务器,如果一个资源很少变动,可以直接缓存,像那些图片、CSS、JS等资源文件可使用缓存

<img src="@img/84c1462ff35d42648c0ad5c5bb1bc74a~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"/>

服务器设置一个请求头:  
- Cache-Control: max-age=31536000  
   > 我希望你可以把这个资源缓存起来，缓存时间为31636000秒（365天）
- Date: Thu, 07 Jul 2022 21:35:20 GMT  
  > 我给你响应这个资源的服务器时间是格林威治时间2022-07-07 21:35:20，如果缓存的时间是365天，那就是在此时间上加上365天
- Etag: W/"3be5f29ac3de039909660e93e1ca5912"  
   > 这个资源编号是 W/"3be5f29ac3de039909660e93e1ca5912"
- Last-Modified: Tue, 05 Jul 2022 15:09:26 GMT  
    > 这个资源上一次修改时间是格林威治时间 2022-07-05 15:09:26

浏览器:  
- 浏览器会将这次请求得到的响应体缓存在本地文件中
- 浏览器会记录这次请求的请求方法和请求路径
- 浏览器会记录本次缓存时间是31536000秒
- 浏览器会记录服务器响应时间是格林威治时间2022-07-07 21:35:20
- 浏览器会记录服务器给予的资源编号是W/"3be5f29ac3de039909660e93e1ca5912"
- 浏览器会记录上一次资源修改的时间是格林威治时间 2022-07-05 15:09:26

请求:  
  1. 首先会判断有没有匹配的缓存,没有就是普通请求
  2. 有缓存
     1. 缓存没有过期
          - 没有过期,使用缓存
          - 过期
             - 会在请求头上设置`If-Modified-Since` 和 `If-None-Match`询问服务器文件是否有变化，没变化就直接使用，这种方式叫做 ***协商缓存(304)***
             
             <img src="@img/06bd3c37896a4fa3ac6595f9c1a181b6~tplv-k3u1fbpfcp-zoom-in-crop-mark_1512_0_0_0.webp"/>
      - If-Modified-Since: Tue, 05 Jul 2022 15:09:26 GMT
        >  这个资源上一次修改时间是格林威治时间 2022-07-05 15:09:26，不知道在这个时间之后有变动吗？
        - If-None-Match: W/"3be5f29ac3de039909660e93e1ca5912"
          > 这个资源编号是 W/"3be5f29ac3de039909660e93e1ca5912" ，请问这个资源编号现在发生改变了吗？

      :::info   
      总结起来就一句话：你快告诉我这个资源到底变了没？之所以要发这两条消息，是为了兼容不同的服务器，因为有的服务器只认If-Modified-Since，而有的服务器只认If-None-Match，有些两个都认。  

      目前有很多服务器，只要发现 ***`If-None-Match`*** 存在，就不会去看`If-Modified-Since`，`If-Modified-Since`是http1.0版本规范，`If-None-Match`是http1.1的规范
      :::
### Cache-Control
Cache-Control在上面已经说过了，它是服务器向浏览器响应的一个消息头，它提供了一个max-age用于指定缓存时间。实际上它还有其他值可以选择。

- 🚀public：表示服务器资源是公开的，对于浏览器来说并没有什么意义，因为大家看到的东西都是一样的，没有变化，也许在某些场景下有用。
- private：表示服务器资源是私有的，比如某个服务器资源，每个用户看到的都不一样，http协议中很多时候都是客户端或者服务器告诉另一端详细的信息，至于另一端用不用完全自己决定。
- 🌵no-cache：这个值看起来字面意思是不缓存的意思😂，其实不然，它会告诉浏览器，你可以缓存这个资源，但是不要直接使用它。当你缓存后，每一次请求都需要附带缓存指令，每一次请求都需要问一下才行，相当于每一次都是协商缓存
- 🌵no-store：告诉浏览器不要缓存这个资源，后面每一次请求都按照普通请求进行，
- 🚀max-age:这个就不说了吧 😎

## 数据格式
### post
form-data 和 application/x-www-form-urlencoded 

:::tip
- 数据包格式的区别，
- 数据包中非ANSCII字符怎么编码，是百分号转码发送还是直接发送
:::

#### application/x-www-form-urlencoded

我们可以看出，服务器知道参数用符号&间隔，如果参数值中需要&，则必须对其进行编码。编码格式就是application/x-www-form-urlencoded（将键值对的参数用&连接起来，如果有空格，将空格转换为+加号；有特殊符号，将特殊符号转换为ASCII HEX值）。

application/x-www-form-urlencoded是 **浏览器默认** 的编码格式。对于Get请求，是将参数转换?key=value&key=value格式，连接到url后

```html
<form action="http://localhost:8888/task/" method="POST">
First name: <input type="text" name="firstName" value="Mickey&"><br>
Last name: <input type="text" name="lastName" value="Mouse "><br>
<input type="submit" value="提交">
</form>
```

<img src="@img/urlencoded.png"/>

#### form-data

multipart/form-data是基于post方法来传递数据的，并且其请求内容格式为Content-Type: multipart/form-data,用来指定请求内容的数据编码格式  

请求体内容各字段之间以--${boundary}来进行分割,以--${boundary}--来结束请求体内容
```txt
POST http://www.example.com HTTP/1.1
Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryyb1zYhTI38xpQxBK

------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="city_id"

1

------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="company_id"

2
------WebKitFormBoundaryyb1zYhTI38xpQxBK
Content-Disposition: form-data; name="file"; filename="chrome.png"
Content-Type: image/png

PNG ... content of chrome.png ...
------WebKitFormBoundaryyb1zYhTI38xpQxBK--

```
##### FormData对象
XMLHttpRequest Level 2添加了一个新的接口FormData。利用FormData对象，我们可以通过JavaScript用一些键值对来模拟一系列表单控件，我们还可以使用XMLHttpRequest的send()方法来异步的提交这个"表单"。
```js
var formData = new FormData();
formData.append("username", "Groucho");
formData.append("accountnum", 123456); 
fetch('/users', {
  method: 'POST',
  body: formData
})
```
通过fetch进行ajax请求时，会自动为其将其转为form-data格式，无需手动添加格式

## [跨域](http://ruanyifeng.com/blog/2016/04/cors.html)


<img src="@img/202301122010888.png"/>
:::danger
虽然跨域，但是服务器依然可以收发响应，只是浏览器拦截
:::

浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）

只要同时满足以下两大条件，就属于简单请求。

```txt
(1) 请求方法是以下三种方法之一：

- HEAD
- GET
- POST

(2)HTTP的头信息不超出以下几种字段：

- Accept
- Accept-Language
- Content-Language
- Last-Event-ID
- Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/- form-data、text/plain
```
这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

复杂请求需要发送一个 **预检请求**

> 对于预见请求，其实就是在发送请求之前，浏览器会先去服务器跑一趟，只携带着请求头，询问服务器是否放行，如果服务器同意，则会发送真实请求
> 
<img src="@img/202301122046532.png"/>

### 细节
#### - 关于cookie
默认情况下，ajax的跨域请求并不会附带cookie

```js
// xhr
var xhr = new XMLHttpRequest();
xhr.withCredentials = true;

// fetch api
fetch(url, {
  credentials: "include"
})
```
当一个请求需要附带cookie时，无论它是简单请求，还是预检（preflight）请求，都会在请求头中添加cookie字段

而服务器响应时，需要明确告知客户端：服务器允许这样的凭据

告知的方式也非常的简单，只需要在响应头中添加：**Access-Control-Allow-Credentials: true** 即可

对于一个附带身份凭证的请求，若服务器没有明确告知，浏览器仍然视为跨域被拒绝。
另外要特别注意的是：对于附带身份凭证的请求，服务器不得设置 Access-Control-Allow-Origin 的值为*。这就是为什么不推荐使用**\***的原因
#### - 关于跨域获取响应头
在跨域访问时，JS只能拿到一些最基本的响应头，如：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma，如果要访问其他头，则需要服务器设置本响应头。

`Access-Control-Expose-Headers` 头让服务器把允许浏览器访问的头放入白名单，例如
服务器回应的其他CORS相关字段如下:
```js
Access-Control-Allow-Methods: GET, POST, PUT //
 // 该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法
Access-Control-Allow-Headers: X-Custom-Header
// 如果浏览器请求包括Access-Control-Request-Headers字段，
// 则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，
// 表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段
Access-Control-Allow-Credentials: true
// 该字段与简单请求时的含义相同。
Access-Control-Max-Age: 1728000
// 该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），
 // 即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求
// Access-Control-Allow-Origin 字段是每次回应都必定包含的
```

#### 否定预检请求
:::tip
如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段
这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的 **onerror回调函数**捕获
:::

## Referrer-Policy

:::tip
当用户在浏览器上点击一个链接时，会产生一个 HTTP 请求，用于获取新的页面内容，而在该请求的报头中，会包含一个 Referrer，用以指定该请求是从哪个页面跳转页来的，常被用于分析用户来源等信息。

但是也有成为用户的一个不安全因素，比如有些网站直接将 sessionid 或是 token 放在地址栏里传递的，会原样不动地当作 Referrer 报头的内容传递给第三方网站
:::



### 指令值
```ts
enum ReferrerPolicy {
  "",
  "no-referrer",
  "no-referrer-when-downgrade",
  "same-origin",
  "origin",
  "strict-origin",
  "origin-when-cross-origin",
  "strict-origin-when-cross-origin",
  "unsafe-url"
}
```
- no-referrer
整个 Referer 首部会被移除。访问来源信息不随着请求一起发送。

- no-referrer-when-downgrade（默认值）
在没有指定任何策略的情况下用户代理的默认行为。在同等安全级别的情况下，引用页面的地址会被发送 (HTTPS->HTTPS)，但是在降级的情况下不会被发送 (HTTPS->HTTP)。

- origin
在任何情况下，仅发送文件的源作为引用地址。例如 https://example.com/page.html 会将 https://example.com/ 作为引用地址。

- origin-when-cross-origin
对于同源的请求，会发送完整的 URL 作为引用地址，但是对于非同源请求仅发送文件的源。

- same-origin
对于同源的请求会发送引用地址，但是对于非同源请求则不发送引用地址信息。

- strict-origin
在同等安全级别的情况下，发送文件的源作为引用地址 (HTTPS->HTTPS)，但是在降级的情况下不会发送 (HTTPS->HTTP)。

- strict-origin-when-cross-origin
对于同源的请求，会发送完整的 URL 作为引用地址；在同等安全级别的情况下，发送文件的源作为引用地址 (HTTPS->HTTPS)；在降级的情况下不发送此首部 (HTTPS->HTTP)。

- unsafe-url
无论是同源请求还是非同源请求，都发送完整的 URL（移除参数信息之后）作为引用地址。

<img src="@img/Referrer-Policy.png"/>

### 集成到 HTML
```html
<meta name="referrer" content="origin">
```
```html
<a href="http://example.com" referrerpolicy="origin">
  <!-- 或者 -->
<a href="http://example.com" rel="noreferrer">
```

## 正向代理与 反向代理
### 正向代理
>如果你去访问 git 的时候，是访问不了的，你 需要 访问 一台可以 访问 git 的服务器
> 客户端 去 访问 这个代理服务器 ，代理服务器 去访问 git

客户端知道 要访问的是哪个服务器，服务器 只知道 是哪个 代理的服务器访问的 ，并不知道是哪一个 客户端 访问的
客户端必须设置正向代理服务器，当然前提是要知道正向代理服务器的 IP 地址，还有代理程序的端口

#### 定义
总结来说：正向代理，"它代理的是客户端"，是一个位于客户端和原始服务器（Origin Server）之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标（原始服务器）。

然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端必须要进行一些特别的设置才能使用正向代理。

#### 正向代理的用途
- 访问原来无法访问的资源，如 Google。
- 可以做缓存，加速访问资源。
- 对客户端访问授权，上网进行认证。
- 代理可以记录用户访问记录（上网行为管理），对外隐藏用户信息

<img src="@img/daiLi.png"/>

### 反向代理
> 我国的某宝网站，每天同时连接到网站的访问人数已经爆表，单个服务器远远不能满足人民日益增长的购买欲望了
> 出现了分布式部署，通过多台服务器来解决访问人数限制的问题
>
####  定义
多个客户端给服务器发送的请求，Nginx 服务器接收到之后，按照一定的规则分发给了后端的业务处理服务器进行处理了
此时请求的来源也就是客户端是明确的，但是请求具体由哪台服务器处理的并不明确了，Nginx 扮演的就是一个反向代理角色。

反向代理，**"它代理的是服务端"**，主要用于服务器集群分布式部署的情况下，反向代理隐藏了服务器的信息。
#### 反向代理的作用
- 保证内网的安全，通常将反向代理作为公网访问地址，Web 服务器是内网。
- 负载均衡，通过反向代理服务器来优化网站的负载。

<img src="@img/daiLi2.png"/>

### 负载均衡
这里提到的客户端发送的、Nginx 反向代理服务器接收到的请求数量，就是我们说的负载量。请求数量按照一定的规则进行分发，到不同的服务器处理的规则，就是一种均衡规则。
所以将服务器接收到的请求按照规则分发的过程，称为负载均衡。

## 网络攻击
### xss
**cross site script(跨站点脚本)**
将 js 脚本插入到 网页内容中，渲染时执行 js 脚本
方法： 替换特殊字符
### csrf
cross site request forgery(跨站请求伪造)

诱导用户请求另一个网站
有一个a 网站，点击按钮 到 b 网站，在 b 网站的时候 ，并发起 a 网站的请求，a 网站会以为是用户自己发起的
比如：一个 gmail 网站，点击按钮到 b网站，在b网站中 转发邮件，由于 带了 a 网站的 cookie
，所以可以执行
方法：预防 跨域 sameSite，验证码，referrer
### click jacking 点击劫持
界面上蒙了一层透明的 iframe，诱导去点击
<img src="@img/clickJack.png"/>