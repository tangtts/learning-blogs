# 校验

## 安装
```bash
pnpm install class-validator class-transformer
```

## 校验类

<blue>注解器是从上到下进行校验</blue>


```ts
async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  app.useGlobalPipes(new ValidationPipe()); // [!code hl]
  await app.listen(3000);
}
bootstrap();
```

1. matches
```ts
  @Matches(/^[a-zA-Z0-9#$%_-]+$/, {
      message: '用户名只能是字母、数字或者 #、$、%、_、- 这些字符'
  })
```
2. @IsString()
3. @IsNotEmpty()
4. @Length(6, 30)
5. @IsNumberString()  ---  数字类型的字符串
6. @IsPhoneNumber("CN") --- 中国手机号
7. @IsOptional() --- 可选
8. @IsBoolean() 布尔值

### [🔗忽略](https://docs.nestjs.com/techniques/validation)
可以忽略前端传进来的多余字段
```ts
app.useGlobalPipes(
  new ValidationPipe({
    whitelist: true, // [!code hl]
  }),
);
```

### 转换
#### transform

> 局部 校验
```ts
@Post()
@UsePipes(new ValidationPipe({ transform: true }))
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```
> 全局转化
```ts
app.useGlobalPipes(
  new ValidationPipe({
    transform: true,
  }),
);
```
效果,因为在 网络传输中，数字会被转换成字符串

```ts
@Get(':id')
findOne(@Param('id') id: number) {
  console.log(typeof id === 'number'); // true
  return 'This action returns a user';
}
```
也可以使用内置的校验方法
```ts
@Get(':id')
findOne(
  @Param('id', ParseIntPipe) id: number,
  @Query('sort', ParseBoolPipe) sort: boolean,
) {
  console.log(typeof id === 'number'); // true
  console.log(typeof sort === 'boolean'); // true
  return 'This action returns a user';
}
```
#### Type 
需要一个构造方法,执行这个构造方法，将值转换成想要的类型
```ts
import {  Type,Transform } from 'class-transformer';
export class VerificationCodeDt {
  @IsEnum(PayType)
  // 转类型
  @Type(() => Number)
  payType: PayType;
}
```

#### Transform
```ts
import {  Type,Transform } from 'class-transformer';
export class VerificationCodeDto {
  @Transform(numberTransformer)
  @IsNumber()
  type: number;
}

export function numberTransformer(params: TransformFnParams) {
  const { value } = params;
  return Number(value);
}
```

### 自定义类型

```ts
import { ValidatorConstraint, ValidatorConstraintInterface, ValidationArguments } from "class-validator";


/**
 *
 * @description 校验是否一致
 * @example password 和 password_confirmed(必须以_confirmed结尾)
 * @export
 * @class IsConfirmed
 * @implements {ValidatorConstraintInterface}
 */
@ValidatorConstraint()
export class IsConfirmed implements ValidatorConstraintInterface {
  validate(text: string, args: ValidationArguments) {
    return text === args.object[`${args.property}_confirmed`];
  }

  /** 默认错误文案 */
  defaultMessage(args: ValidationArguments) {
    return "二次确认不一致";
  }
}
```

使用

```ts
export class CreateUserDTO {
  @Validate(IsConfirmed,{message:"两次密码不一致"})
  password:string

  @Length(3,6)
  password_confirmed:string
}
```

### 默认值

```ts
export class TodoDTO{
  @IsBoolean()
  isComplated:boolean = false
}
```

## 类型

```ts
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}
```
### PartialType
```ts
export class UpdateCatDto extends PartialType(CreateCatDto) {}
```
### PickType
```ts
export class UpdateCatAgeDto extends PickType(CreateCatDto, ['age'] as const) {}
```
### OmitType
```ts
export class UpdateCatDto extends OmitType(CreateCatDto, ['name'] as const) {}
```
### IntersectionType
```ts
export class CreateCatDto {
  name: string;
  breed: string;
}

export class AdditionalCatInfo {
  color: string;
}
```
合并两个类型

```ts
export class UpdateCatDto extends IntersectionType(
  CreateCatDto,
  AdditionalCatInfo,
) {}
```
### 联合类型

```ts
export class UpdateCatDto extends PartialType(
  OmitType(CreateCatDto, ['name'] as const),
) {}
```